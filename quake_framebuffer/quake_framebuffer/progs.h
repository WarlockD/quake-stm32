/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#ifndef _QUAKE_PRODGS_H_
#define _QUAKE_PRODGS_H_

#include "pr_comp.h"			// defs shared with qcc
#include "progdefs.h"			// generated by program cdefs

struct edict_t;

struct  eval_t {
	union {
		cstring_t		string;
		float			_float;
		vec3_t			vector;
		const dfunction_t*			function;
		int				_int;
		edict_t*		edict;
		const ddef_t*	field;		
	};
};



#define	MAX_ENT_LEAFS	16
// ok, this took a while.  So this is just a big enity with random space at the end that contain stuff
// so I am putting in a map to trace down how often things are set and such
#include <functional>
// this might use a bunch of space, howerver its better than
// allocated a full 1000 bytes for each edict for something that might have one or two values
// we could use two maps for this but better to be custom for hulk sake
// hash map would be faster but bucket managment is iffy with our memory model
struct off_name_map_t {
	std::map<string_t, const ddef_t *> string_debug_lookup;
	std::vector<const ddef_t *> offset_debug_lookup;
	void clear() {
		string_debug_lookup.clear();
		offset_debug_lookup.clear();
	}
	const ddef_t * lookup(ptrdiff_t k) const {
		assert(offset_debug_lookup[k] != nullptr);
		return offset_debug_lookup[k];
	}
	const ddef_t * lookup(const quake::string_view& k) const {
		auto it = string_debug_lookup.find(k);
		if (it == string_debug_lookup.end()) return nullptr;
		return it->second;
	}
	void insert(const ddef_t * def);
	struct data_lookup_t {
		off_name_map_t& _map;
		void* _start;
		template<typename T>
		inline T* cast_offset(ptrdiff_t k) { return reinterpret_cast<T*>(reinterpret_cast<float*>(_start) + k); }
		template<typename T>
		inline  const T* cast_offset(ptrdiff_t k) const  { return reinterpret_cast<const T*>(reinterpret_cast<const float*>(_start) + k); }
		const ddef_t* checktype(const quake::string_view& name, const idType& type) const {
			const ddef_t* def = _map.lookup(string_t::intern(name));
			assert(def);
			if (type != etype_t::ev_void) {
				if (type != def->type)
					quake::con << "Wrong type get for '" << def->name() << "'  [" << idType(def->type) << "]->[" << type << "]" << std::endl;
			}
			return def;
		}
		const ddef_t* checktype(ptrdiff_t k, const idType& type) const {
			const ddef_t* def = _map.lookup(k);
			assert(def);
			if (type != etype_t::ev_void) {
				if (type != def->type)
					quake::con << "Wrong type get for '" << def->name() << "'  [" << idType(def->type) << "]->[" << type << "]" << std::endl;
			}
			return def;
		}
	public:
		data_lookup_t(off_name_map_t& map, void* start=nullptr) : _map(map), _start(start) {}
		void set_data(void* data) { _start = data; }

		eval_t* get(const quake::string_view& name, idType type = etype_t::ev_void)  {
			return cast_offset<eval_t>(checktype(name, type)->ofs);
		}
		const eval_t* get(const quake::string_view& name, idType type = etype_t::ev_void) const {
			return cast_offset<eval_t>(checktype(name, type)->ofs);
		}
		eval_t* get( ptrdiff_t k, idType type = etype_t::ev_void) {
			// test offset ot make sure we are equal?

			return cast_offset<eval_t>(checktype(k, type)->ofs);
		}
		const eval_t* get( ptrdiff_t k, idType type = etype_t::ev_void) const {
			return cast_offset<eval_t>(checktype(k, type)->ofs);
		}
		template<typename T>
		void set( ptrdiff_t k, const T& v) {
			auto def = _map.lookup(k);
			assert(def);
			static_assert(sizeof(T) == sizeof(float) * 3 || sizeof(T) == sizeof(float), "Incorrect size");
			std::memcpy(get(k, etype_t::ev_void), &v, sizeof(T));
		}
		template<typename T>
		void set(const quake::string_view& k, const T& v) {
			auto def = _map.lookup(k);
			assert(def);
			static_assert(sizeof(T) == sizeof(float) * 3 || sizeof(T) == sizeof(float), "Incorrect size");
			std::memcpy(get(k, etype_t::ev_void), &v, sizeof(T));
		}
		void set(const quake::string_view& k, bool v) { set(k, (v ? 1.0f : 0.0f)); }
		void set(ptrdiff_t k, bool v) { set(k, (v ? 1.0f : 0.0f)); }
		inline eval_t* get_eval(ptrdiff_t o) { return get(o, etype_t::ev_void); }
		inline const eval_t* get_eval(ptrdiff_t o) const { return get(o, etype_t::ev_void); }
		inline float& get_float(ptrdiff_t o) { return get(o, etype_t::ev_float)->_float; }
		inline const float& get_float(ptrdiff_t o) const { return get(o, etype_t::ev_float)->_float; }
		inline int& get_int(ptrdiff_t o) { return reinterpret_cast<int&>(get_float(o)); }
		inline const int& get_int(ptrdiff_t o) const { return reinterpret_cast<const int&>(get_float(o)); }
		inline vec3_t& get_vector(ptrdiff_t o) { return  get(o, etype_t::ev_vector)->vector; }
		inline const vec3_t& get_vector(ptrdiff_t o) const { return get(o, etype_t::ev_vector)->vector; }
		cstring_t get_string(ptrdiff_t k) const { return get(k, etype_t::ev_string)->string; }
		cstring_t get_string(const quake::string_view& k) const { return get(k, etype_t::ev_string)->string; }

		edict_t* get_edict(ptrdiff_t k) const { return get(k, etype_t::ev_entity)->edict; }
		const edict_t* et_edict(eval_t* start, ptrdiff_t k) { return get(k, etype_t::ev_entity)->edict; }

		inline eval_t* get_eval(const quake::string_view& o) { return get(o, etype_t::ev_void); }
		inline const eval_t* get_eval(const quake::string_view& o) const { return get(o, etype_t::ev_void); }
		inline float& get_float(const quake::string_view& o) { return get(o, etype_t::ev_float)->_float; }
		inline const float& get_float(const quake::string_view& o) const { return get(o, etype_t::ev_float)->_float; }
		inline int& get_int(const quake::string_view& o) { return reinterpret_cast<int&>(get_float(o)); }
		inline const int& get_int(const quake::string_view& o) const { return reinterpret_cast<const int&>(get_float(o)); }
		inline vec3_t& get_vector(const quake::string_view& o) { return  get(o, etype_t::ev_vector)->vector; }
		inline const vec3_t& get_vector(const quake::string_view& o) const { return get(o, etype_t::ev_vector)->vector; }
		cstring_t& get_string(ptrdiff_t k)  { return get(k, etype_t::ev_string)->string; }
		cstring_t& get_string(const quake::string_view& k)  { return get(k, etype_t::ev_string)->string; }
	};
};

struct const_value_t {
	const_value_t(idType type, const eval_t* value) : _value(value), _type(type) {}
	const_value_t() : _value(nullptr), _type(etype_t::ev_void) {}
	const_value_t(const void* base , const ddef_t* def) : 
		_value(reinterpret_cast<const eval_t*>(reinterpret_cast<const uint8_t*>(base) + def->ofs)), _type(def->type) {}
	const eval_t* value() const { return _value; }
	idType type() const { return _type; }
	float get_float() const { assert(_type == etype_t::ev_float);  return _value->_float; }
	cstring_t get_string() const { assert(_type == etype_t::ev_string);  return _value->string; }
	operator float() const { return get_float(); }
	operator cstring_t() const { return get_string(); }
public:
	idType _type;
	const eval_t* _value;
};

struct value_t : public const_value_t {
	value_t(idType type, eval_t* value) : const_value_t(type, value) {}
	value_t() : const_value_t() {}
	value_t(void* base, const ddef_t* def) : const_value_t(base, def) {}
	eval_t* value()  { return const_cast<eval_t*>(_value); }
	template<typename T, REQUIRES(etype_traits<T>::value)>
	void set(const T& v) { std::memcpy(value(), &v, sizeof(T)); }
	template<typename T>
	const T& operator=(const T& v) { set(v); return v; }
};

struct edict_t {
	off_name_map_t::data_lookup_t vars;


	bool free;
	list::entry<edict_t>  area; // linked to a division node or leaf
	int num;
	int offset;
	int			num_leafs;
	short		leafnums[MAX_ENT_LEAFS];
	entity_state_t	baseline;
	idTime		freetime;			// sv.time when the object was freed
	union {
		float v_floats[1];
		edict_t* v_edicts[1];
		string_t v_strings[1];
		eval_t	v_evals[1];
		entvars_t v;
	};


	edict_t(int num, int offset);
	~edict_t();

	void ClearFields();



	inline eval_t* E_EVAL(ptrdiff_t o) { return vars.get(o, etype_t::ev_void); }
	inline const eval_t* E_EVAL(ptrdiff_t o) const { return vars.get(o, etype_t::ev_void); }
	inline eval_t* E_EVAL(const quake::string_view& o) { return vars.get(o, etype_t::ev_void); }
	inline const eval_t* E_EVAL(const quake::string_view& o) const { return vars.get(o, etype_t::ev_void); }

	
	inline float& E_FLOAT(ptrdiff_t o) { return vars.get(o,etype_t::ev_float)->_float; }
	inline const float& E_FLOAT(ptrdiff_t o) const { return vars.get(o, etype_t::ev_float)->_float; }
	inline vec3_t& E_VECTOR(ptrdiff_t o) { return vars.get(o, etype_t::ev_vector)->vector; }
	inline const vec3_t& E_VECTOR(ptrdiff_t o) const { return vars.get(o, etype_t::ev_vector)->vector; }
	inline cstring_t& E_STRING(ptrdiff_t o) { return vars.get(o, etype_t::ev_string)->string; }
	inline const cstring_t& E_STRING(ptrdiff_t o) const { return vars.get(o, etype_t::ev_string)->string; }


	void set(ptrdiff_t o, float v) { E_FLOAT(o) = v; }
	void set(ptrdiff_t o, int v) { E_FLOAT(o) = static_cast<float>(v); }
	template<typename T>
	void set(ptrdiff_t k, const T& v) { 
		static_assert(sizeof(T) == 3 || sizeof(T) == 1, "Incorrect size");
		std::memcpy(vars.get(k, etype_t::ev_void),&v,sizeof(T));
	}
	template<typename T>
	void set(const quake::string_view& k, const T& v) {
		static_assert(sizeof(T) == 1||  "Incorrect size");
		std::memcpy(vars.get(k, etype_t::ev_void), &v, sizeof(T));
	}
	void set(const quake::string_view& k, const vec3_t& v) {
		std::memcpy(vars.get(k, etype_t::ev_void), &v, sizeof(vec3_t));
	}
	value_t operator[](ptrdiff_t off) ;
	const_value_t operator[](ptrdiff_t off) const;
	value_t operator[](const quake::string_view& off) ;
	const_value_t operator[](const quake::string_view& off)const;
	void Print();
	//static void* operator new(size_t size);
	//static void operator delete(void* ptr);

// other fields from progs come immediately after
} ;



namespace quake {
	class PR_ValueString : public stream_output {
		idType type;
		eval_t *val;
	public:
		PR_ValueString(idType type, eval_t *val) : type(type), val(val) {}
		void text_output(std::ostream& os) const override final;
	};
	class  PR_GlobalString : public stream_output {
		int ofs;
		idType type;
	public:
		PR_GlobalString(int ofs) : ofs(ofs),type() {}
		PR_GlobalString(int ofs, idType type) : ofs(ofs), type(type) {}
		void text_output(std::ostream& os)  const override final;
	};
	class  PR_GlobalStringNoContents : public stream_output {
		int ofs;
		idType type;
	public:
		PR_GlobalStringNoContents(int ofs) : ofs(ofs), type(type) {}
		PR_GlobalStringNoContents(int ofs, idType type) : ofs(ofs), type(type) {}
		void text_output(std::ostream& os)  const override final;
	};
};


class idValue {
public:
	idValue() : _type() {}
	idValue(eval_t* value, idType type) : _value(value), _type(type) {}
	idValue(quake::string_view name, eval_t* value, idType type) : _value(value), _type(type){}
	idValue(quake::string_view name, eval_t* value,const ddef_t* def) : _value(value), _type(def ? def->type : etype_t::ev_void) {}
	const eval_t& value() const { return *_value; }
	eval_t& value()  { return *_value; }
	const idType& type() const { return _type; }
	string_t name() const;
private:
	idType _type;
	eval_t* _value;
};


void PR_Profile_f(cmd_source_t source, const StringArgs& args);
void ED_Write(std::ostream& f, edict_t *ed);
edict_t * ED_ParseEdict(COM_Parser& data, edict_t *ent=nullptr);

void ED_WriteGlobals(std::ostream& f);
void ED_ParseGlobals(COM_Parser& data);

void ED_LoadFromFile(const quake::string_view& data);

typedef void(*builtin_t) (void);
extern	builtin_t *pr_builtins;
extern int pr_numbuiltins;
extern int pr_argc;

void PR_RunError(const char* str);
void ED_PrintEdicts(void);
void ED_PrintNum(int ent);


struct pr_system_t {
	//using edict_list_t = tailq::head<edict_t, &edict_t::alloc_list>;
	inline static bool edict_sort_by_index(const edict_t* l, const edict_t* r)  noexcept { return l->num < r->num; }
	inline static bool edict_sort_by_offset(const edict_t* l, const edict_t* r)  noexcept { return reinterpret_cast<ptrdiff_t>(l)< reinterpret_cast<ptrdiff_t>(r); }
	//edict_t *		pr_edicts;		// makes sence to put the edicts here 
	struct edict_sort_by_index_t { bool operator()(const edict_t* l, const edict_t* r) const noexcept { return edict_sort_by_index(l, r); }; };
	struct edict_sort_by_offset_t { bool operator()(const edict_t* l, const edict_t* r) const noexcept { return edict_sort_by_offset(l, r); }; };
	
	
	off_name_map_t _field_info;
	off_name_map_t _global_info;
	off_name_map_t::data_lookup_t vars;
	std::map<string_t, const dfunction_t *> _function_info;

	std::vector<edict_t*> pr_edicts;
	std::size_t		pr_max_edicts;
	// instead of pools use queues?
	std::set<edict_t*> used_pool;
	std::set<edict_t*> reserved_pool; // these are edicts that arn't used
	std::deque<edict_t*> free_pool;




	dprograms_t		*progs;
	const dfunction_t		*pr_functions;
	const dfunction_t		*pr_xfunction;
	int				pr_xstatement;
	//const char		*pr_strings;

	const ddef_t			*pr_globaldefs;
	const ddef_t			*pr_fielddefs;
	const dstatement_t		*pr_statements;

	globalvars_t	*pr_global_struct;
	float			*pr_globals;			// same as pr_global_struct

	value_t operator[](ptrdiff_t off)  { return value_t(pr_global_struct, _global_info.lookup(off)); }
	const_value_t operator[](ptrdiff_t off) const { return const_value_t(pr_global_struct, _global_info.lookup(off)); }
	value_t operator[](const quake::string_view& off)  { return value_t(pr_global_struct, _global_info.lookup(off)); }
	const_value_t operator[](const quake::string_view& off) const { return const_value_t(pr_global_struct, _global_info.lookup(off)); }

	int				pr_edict_size;	// in bytes
	std::vector<idType> _globaltypes;  // quick lookup agesnt the types in global vars

	
	size_t used_edicts() const { return used_pool.size(); }
	auto begin() { return used_pool.begin(); }
	auto end() { return used_pool.end(); }
	auto begin() const { return used_pool.begin(); }
	auto end() const { return used_pool.end(); }
	inline edict_t *EDICT_NUM(size_t n)
	{
		if (n < 0 || n >= pr_max_edicts)
			Sys_Error("EDICT_NUM: bad number %i", n);
		return pr_edicts[n]; // (edict_t *)((byte *)pr_edicts + (n)*pr_edict_size);
	}
	inline const edict_t *EDICT_NUM(size_t n) const
	{
		if (n < 0 || n >= pr_max_edicts)
			Sys_Error("EDICT_NUM: bad number %i", n);
		return  pr_edicts[n]; // (const edict_t *)((const byte *)pr_edicts + (n)*pr_edict_size);
	}
	inline size_t NUM_FOR_EDICT(const edict_t* e) const { return e->num; }
	const ddef_t *ED_GlobalAtOfs(int ofs)const { return _global_info.lookup(ofs); }
	const ddef_t *ED_FieldAtOfs(int ofs) const { return _field_info.lookup(ofs); }
	const ddef_t *ED_FindGlobal(const quake::string_view& name)const { return _global_info.lookup(name); }
	const ddef_t *ED_FindField(const quake::string_view& name)const { return _field_info.lookup(name); }


	size_t ED_FindFunctionIndex(const quake::string_view&  name) const {
		auto it = _function_info.find(name);
		return it->second - pr_functions;
	}
	const dfunction_t *ED_FindFunction(const quake::string_view&  name) const {
		auto it = _function_info.find(name);
		return it != _function_info.end() ? it->second : nullptr;
	}
	const dfunction_t *ED_FindFunction(int ofs) const { return pr_functions + ofs; }

	
	void ED_HulkAllocEdicts(size_t size);
	edict_t *ED_Alloc(bool reserve = false, edict_t *ent =nullptr);

	void ED_Free(edict_t *e);


	int	EDICT_TO_PROG(edict_t* e) const { 
		int offset = e->offset;
		assert((offset % pr_edict_size) == 0);
		return offset;
	}
	edict_t* PROG_TO_EDICT(int e) const {
		assert((e % pr_edict_size) == 0);
		const size_t i = e / pr_edict_size;
		return pr_edicts[i];
	}
	std::pair<edict_t*, eval_t*> PROG_TO_EDICT_AND_FIELD(int e) const {
		edict_t* ed = PROG_TO_EDICT(e / pr_edict_size);
		eval_t* value = ed->E_EVAL(e % pr_edict_size);
		return std::make_pair(ed, value);
	}

	// remove this one
	edict_t* NEXT_EDICT(edict_t* e) const {  return ((edict_t *)((byte *)e + pr_edict_size)); }
	bool is_edict_free(edict_t* e) const { return e->free; }
	const char* ED_QuickToString(uint8_t v) const; // quickly finds a number to string, super fast
	const char* ED_LocalModelName(uint8_t v) const; // quickly finds a number to string, super fast
	string_t ED_NewString(const quake::string_view& string, bool zmalloc = false);
	void ED_ClearStrings();
	inline eval_t* G_EVAL(ptrdiff_t o) { return vars.get(o, etype_t::ev_void); }
	inline const eval_t* G_EVAL(ptrdiff_t o) const { return vars.get(o, etype_t::ev_void); }

	inline float& G_FLOAT(ptrdiff_t o) { return vars.get_float(o); }
	inline const float& G_FLOAT(ptrdiff_t o) const { return vars.get_float(o);}

	inline int& G_INT(ptrdiff_t o) { return vars.get_int(o); }
	inline const int& G_INT(ptrdiff_t o) const { return vars.get_int(o); }
	inline vec3_t& G_VECTOR(ptrdiff_t o) { return vars.get_vector(o); }
	inline const vec3_t& G_VECTOR(ptrdiff_t o) const { return vars.get_vector(o);}
	cstring_t G_STRING(ptrdiff_t o) const { return vars.get_string(o);}
	cstring_t& G_STRING(ptrdiff_t o)  { return vars.get_string(o); }
	edict_t*G_EDICT(ptrdiff_t o) { return vars.get_edict(o); }
	const edict_t*G_EDICT(ptrdiff_t o) const { return vars.get_edict(o); }
	int G_EDICTNUM(ptrdiff_t o) const { return NUM_FOR_EDICT(G_EDICT(o)); }
	const dfunction_t*&G_FUNCTION(ptrdiff_t o)  { return vars.get(o, etype_t::ev_function)->function; }
	const dfunction_t*G_FUNCTION(ptrdiff_t o) const { return vars.get(o, etype_t::ev_function)->function; }
	void RETURN_EDICT(edict_t* e) { G_INT(OFS_RETURN) = EDICT_TO_PROG(e); }
	// returns a copy of the string allocated from the server's string heap

	pr_system_t();
	pr_system_t(const pr_system_t& copy) = default;
	pr_system_t(pr_system_t&& move) = default;
	pr_system_t& operator=(const pr_system_t& copy) = default;
	pr_system_t& operator=(pr_system_t&& move) = default;
	~pr_system_t() = default;

	void LoadProgs();
	void Clear();
	void Init();

	unsigned short		pr_crc;
};


extern pr_system_t vm;
inline value_t edict_t::operator[](ptrdiff_t off)  { return value_t(&v, vm._field_info.lookup(off)); }
inline const_value_t edict_t::operator[](ptrdiff_t off) const { return const_value_t(&v, vm._field_info.lookup(off)); }
inline value_t edict_t::operator[](const quake::string_view& off)  { return value_t(&v, vm._field_info.lookup(off)); }
inline const_value_t edict_t::operator[](const quake::string_view& off) const { return const_value_t(&v, vm._field_info.lookup(off)); }


inline cstring_t field_t::name() const {
	return (vm.pr_fielddefs + _index)->name();
}
inline size_t field_t::offset() const {
	return (vm.pr_fielddefs + _index)->ofs;
}
inline void off_name_map_t::insert(const ddef_t * def) {
	string_debug_lookup.emplace(string_t(def->name()), def);
	if (def->ofs >= offset_debug_lookup.size()) offset_debug_lookup.resize(def->ofs + 1);
	offset_debug_lookup[def->ofs] = def;
}

//inline string_t::string_t(size_t index) : string_t(vm.pr_strings + index) {}



inline cstring_t func_t::name() const {
	auto func = vm.ED_FindFunction(_index);
	return func->name().c_str();
}

#endif