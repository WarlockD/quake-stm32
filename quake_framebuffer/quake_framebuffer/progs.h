/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#ifndef _QUAKE_PRODGS_H_
#define _QUAKE_PRODGS_H_

#include "pr_comp.h"			// defs shared with qcc
#include "progdefs.h"			// generated by program cdefs

union eval_t
{
	string_t		string;
	float			_float;
	float			vector[3];
	func_t			function;
	int				_int;
	int				edict;
} ;	

#define	MAX_ENT_LEAFS	16
// ok, this took a while.  So this is just a big enity with random space at the end that contain stuff
// so I am putting in a map to trace down how often things are set and such
#include <functional>

struct edict_t
{
#ifdef USE_OLD_EDICT_SYSTEM
	qboolean	free;
	void Free();
	void Unlink();
	void Clear();
#else

#endif
	tailq::entry<edict_t>  alloc_list; // linked to a division node or leaf
	bool free;
	list::entry<edict_t>  area; // linked to a division node or leaf
	const int num;

	edict_t(int num);
	~edict_t();
	void ClearFields();

	int			num_leafs;
	short		leafnums[MAX_ENT_LEAFS];

	entity_state_t	baseline;
	
	idTime		freetime;			// sv.time when the object was freed
	struct vector_t {
		float value[3];
		vector_t() : value { 0.0f, 0.0f, 0.0f } {}
		vector_t(float* f) { ::memcpy(value, f, sizeof(value)); }
	};
	struct value_t {
		std::variant<nullptr_t, quake::string_view, float, vector_t, edict_t*, int, dfunction_t*> value;
		etype_t type;
		template<typename T>
		value_t(etype_t t, T&& v) :value(std::forward<T>(v)), type(t) {}
		value_t(nullptr_t) :value(nullptr), type(etype_t::ev_void) {}
		value_t(quake::string_view v) :value(v), type(etype_t::ev_string) {}
		value_t(float v) :value(v), type(etype_t::ev_float) {}
		value_t(vector_t v) :value(v), type(etype_t::ev_vector) {}
		value_t(edict_t* v) :value(v), type(etype_t::ev_entity) {}
		value_t(int v) :value(v), type(etype_t::ev_field) {}
		value_t(dfunction_t* v) :value(v), type(etype_t::ev_function) {}
	};
	using map_t = std::unordered_map<quake::string_view, value_t>;
	map_t vars;
	union {
		float  fields[1]; // must be the last
		entvars_t v;					// C exported fields from progs
	};
	inline float& E_FLOAT(ptrdiff_t o) { return fields[o]; }
	inline const float& E_FLOAT(ptrdiff_t o) const { return fields[o]; }
	inline int& E_INT(ptrdiff_t o) { return reinterpret_cast<int&>(fields[o]); }
	inline const int& E_INT(ptrdiff_t o) const { return reinterpret_cast<const int&>(fields[o]); }
	inline vec3_t& E_VECTOR(ptrdiff_t o) { return reinterpret_cast<vec3_t&>(fields[o]); }
	inline const vec3_t& E_VECTOR(ptrdiff_t o) const { return reinterpret_cast<const vec3_t&>(fields[o]); }
	inline const char* E_STRING(ptrdiff_t o) const;


	eval_t& edict_t::get_field(ptrdiff_t o) { return reinterpret_cast<eval_t&>(fields[o]); }
	const eval_t& edict_t::get_field(ptrdiff_t o) const { return reinterpret_cast<const eval_t&>(fields[o]); }
	eval_t& edict_t::get_field(const quake::string_view& field);
	const eval_t& edict_t::get_field(const quake::string_view& field) const;

	void Print();
	//static void* operator new(size_t size);
	//static void operator delete(void* ptr);

// other fields from progs come immediately after
} ;



namespace quake {
	class PR_ValueString : public stream_output {
		idType type;
		eval_t *val;
	public:
		PR_ValueString(idType type, eval_t *val) : type(type), val(val) {}
		void text_output(std::ostream& os) const override final;
	};
	class  PR_GlobalString : public stream_output {
		int ofs;
	public:
		PR_GlobalString(int ofs) : ofs(ofs) {}
		void text_output(std::ostream& os)  const override final;
	};
	class  PR_GlobalStringNoContents : public stream_output {
		int ofs;
	public:
		PR_GlobalStringNoContents(int ofs) : ofs(ofs) {}
		void text_output(std::ostream& os)  const override final;
	};
}

class idValue {
public:
	idValue() : _type() {}
	idValue(eval_t* value, idType type) : _value(value), _type(type) {}
	const eval_t& value() const { return *_value; }
	eval_t& value()  { return *_value; }
	const idType& type() const { return _type; }
private:
	idType _type;
	eval_t* _value;
};
#define	EDICT_FROM_AREA(l) STRUCT_FROM_LINK(l,edict_t,area)


struct pr_system_t {
	using edict_list_t = tailq::head<edict_t, &edict_t::alloc_list>;
	dprograms_t		*progs;
	dfunction_t		*pr_functions;
	dfunction_t		*pr_xfunction;
	int				pr_xstatement;
	char			*pr_strings;

	ddef_t			*pr_globaldefs;
	ddef_t			*pr_fielddefs;
	dstatement_t	*pr_statements;
	globalvars_t	*pr_global_struct;
	float			*pr_globals;			// same as pr_global_struct

	int				pr_edict_size;	// in bytes
	//edict_t *		pr_edicts;		// makes sence to put the edicts here 
	std::vector<edict_t*> pr_edicts;
	size_t		pr_max_edicts;

	edict_list_t free_pool;
	edict_list_t used_pool;
	edict_list_t reserved_pool; // edicts for clients and world 0->svs.maxclients + 1
	size_t pr_num_edicts;


	auto begin() { return used_pool.end(); }
	auto end() { return used_pool.end(); }
	inline edict_t *EDICT_NUM(size_t n)
	{
		if (n < 0 || n >= pr_max_edicts)
			Sys_Error("EDICT_NUM: bad number %i", n);
		return pr_edicts[n]; // (edict_t *)((byte *)pr_edicts + (n)*pr_edict_size);
	}
	inline const edict_t *EDICT_NUM(size_t n) const
	{
		if (n < 0 || n >= pr_max_edicts)
			Sys_Error("EDICT_NUM: bad number %i", n);
		return  pr_edicts[n]; // (const edict_t *)((const byte *)pr_edicts + (n)*pr_edict_size);
	}
	inline size_t NUM_FOR_EDICT(const edict_t* e) const {
		return e->num;
#if 0
		int b = (byte *)e - (byte *)pr_edicts;
		b = b / pr_edict_size;

		if (b < 0 || b >= pr_num_edicts)
			Sys_Error("NUM_FOR_EDICT: bad pointer");
		return b;
#endif
	}
	ddef_t *ED_GlobalAtOfs(int ofs);
	ddef_t *ED_FieldAtOfs(int ofs);
	ddef_t *ED_FindField(const quake::string_view& name);
	ddef_t *ED_FindGlobal(const quake::string_view& name);
	dfunction_t *ED_FindFunction(const quake::string_view& name);
	void ED_HulkAllocEdicts(size_t size);
	edict_t *ED_Alloc(bool reserve = false);
	void ED_Free(edict_t *e);
	// string system
	//string_t pr_strings_last_offset; // last valid offset for new strings in lookup
	using string_lookup_t = std::unordered_map<quake::string_view, string_t>;
	string_lookup_t pr_strings_lookup;
	const string_lookup_t::value_type& ED_NewString(const quake::string_view& string);

	int		 EDICT_TO_PROG(edict_t* e) const { return ((byte *)e - (byte *)pr_edicts[0]); }
	edict_t* PROG_TO_EDICT(int e) const { assert((e % pr_edict_size) == 0); return (edict_t *)((byte *)pr_edicts[0] + e); }
	// remove this one
	edict_t* NEXT_EDICT(edict_t* e) const {  return ((edict_t *)((byte *)e + pr_edict_size)); }
	bool is_edict_free(edict_t* e) const {
		return e->free;
#if 0
			block_header_t* eb = reinterpret_cast<block_header_t*>(reinterpret_cast<byte*>(e) - sizeof(block_header_t));

			return eb->free;
#endif
	}
	// for the vm system.  have to be careful as the vm uses offsets of the memory space
	template<typename T> T* globals(size_t o) { return reinterpret_cast<T*>(&pr_globals[o]); }

	float&G_FLOAT(ptrdiff_t o) { return pr_globals[o]; }
	const float&G_FLOAT(ptrdiff_t o) const { return pr_globals[o]; }
	int&G_INT(ptrdiff_t o) { return reinterpret_cast<int&>(pr_globals[o]); }
	const int&G_INT(ptrdiff_t o) const { return reinterpret_cast<const int&>(pr_globals[o]); }
	edict_t*G_EDICT(ptrdiff_t o) { return reinterpret_cast<edict_t *>(reinterpret_cast<byte *>(pr_edicts[0]) +G_INT(o)); }
	const edict_t*G_EDICT(ptrdiff_t o) const { return reinterpret_cast<const edict_t *>(reinterpret_cast<const byte *>(pr_edicts[0]) + G_INT(o)); }
	int G_EDICTNUM(ptrdiff_t o) const { return NUM_FOR_EDICT(G_EDICT(o)); }
	vec3_t&G_VECTOR(ptrdiff_t o) { return reinterpret_cast<vec3_t&>(pr_globals[o]); }
	const vec3_t&G_VECTOR(ptrdiff_t o) const { return reinterpret_cast<const vec3_t&>(pr_globals[o]); }
	const char*G_STRING(ptrdiff_t o) const{ return pr_strings+ G_INT(o); }
	func_t&G_FUNCTION(ptrdiff_t o)  { return reinterpret_cast<func_t&>(pr_globals[o]);}
	const func_t&G_FUNCTION(ptrdiff_t o) const { return reinterpret_cast<const func_t&>(pr_globals[o]); }
	void RETURN_EDICT(edict_t* e) { reinterpret_cast<int*>(pr_globals)[OFS_RETURN] = EDICT_TO_PROG(e); }
	// returns a copy of the string allocated from the server's string heap

	pr_system_t();
	void LoadProgs();
	void Clear();
	void Init();

	unsigned short		pr_crc;
};
extern pr_system_t vm;

const char* edict_t::E_STRING(ptrdiff_t o) const {
	return vm.pr_strings + E_INT(o);
}
//void* edict_t::operator new(size_t size) { return vm.ED_Alloc(); }
//void edict_t::operator delete(void* ptr) { vm.ED_Free((edict_t*)ptr); }

//============================================================================



//============================================================================

//void PR_Init (void);

void PR_ExecuteProgram (func_t fnum);
//void PR_LoadProgs (void);

void PR_Profile_f(cmd_source_t source, size_t argc, const quake::string_view argv[]);



//void ED_Print (edict_t *ed);
void ED_Write (std::ostream& f, edict_t *ed);
bool ED_ParseEdict (COM_Parser& data, edict_t *ent);

void ED_WriteGlobals (std::ostream& f);
void ED_ParseGlobals (COM_Parser& data);

void ED_LoadFromFile (const quake::string_view& data);


//============================================================================




typedef void (*builtin_t) (void);
extern	builtin_t *pr_builtins;
extern int pr_numbuiltins;

extern int		pr_argc;

extern	qboolean	pr_trace;




void PR_RunError(const char* str);
void ED_PrintEdicts (void);
void ED_PrintNum (int ent);

#endif